import tkinter
import customtkinter
from PIL import Image
from customtkinter import CTkLabel, CTkScrollableFrame, CTkButton
from app_requests import register, get_token, get_history, new_message, get_worker_address_async
import asyncio
import threading


"""
Code of YMessenger GUI client. Run it to use GUI client for messenger.
GUI built using customtkinter, wrapper for tkinter.

It runs in two threads: for GUI library and for updates loop.

All images are generated by Bing.
"""


CURRENT_CHAT = ""
USERNAME = ""
PASSWORD = ""
All_messages = []
TOKEN = ""
to_send = []
USER_STEP = "logging"

chats_frame = None
recipient_label = None


class ToplevelWindow(customtkinter.CTkToplevel):
    """
    Custom class to make windows with messages. Used in popup to display errors.
    """

    def __init__(self, message, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.geometry("300x200")

        self.label = customtkinter.CTkLabel(self, text=message)
        self.label.pack(padx=20, pady=20)


class ScrollableChatsFrame(CTkScrollableFrame):
    """
    Custom class for chats scrollable frame on the left. Can be scrolled using scroll-wheel or slide bar on right side.
    """

    def __init__(self, master, messages_frame, **kwargs):
        super().__init__(master, **kwargs, scrollbar_fg_color="transparent")
        self.grid_columnconfigure(0, weight=1)

        self.radiobutton_variable = customtkinter.StringVar()
        self.messages_frame = messages_frame
        self.chats = []

    def add_chat(self, chat_username, header):
        """
        Adds chat button at the bottom to itself.

        :param chat_username: dialog name, that will be displayed on chat button
        :param header: app header, that shows current dialog name.
        :return: returns None.
        """
        button = CTkButton(self, text=chat_username, width=300, height=50)
        button.configure(
            compound="left", command=lambda: self.messages_frame.open_chat(chat_username, header), corner_radius=0
        )
        button.grid(row=len(self.chats), column=0, pady=(0, 2), padx=5, sticky="nsew")
        self.chats.append(button)

    def reload_all_chats(self, mess: list, header: CTkLabel):
        """
        Clears itself and loads all chats from zero.

        :param mess: list of all user's messages, that will be displayed.
        :param header: app header, that shows current dialog name.
        :return: returns None.
        """
        self.clear_chats()
        for i in range(len(mess)):
            self.add_chat(mess[i], header)
        self.add_chat("New chat +", "start_conversation")
        self.messages_frame.open_chat(CURRENT_CHAT, header)

    def clear_chats(self):
        """
        Clears all chats from frame.

        :return: Returns None.
        """
        for button in self.chats:
            button.destroy()


class ScrollableMessagesFrame(CTkScrollableFrame):
    """
    Custom class messages scrollable frame on the right. Can be scrolled using scroll-wheel.
    """

    def __init__(self, master, command=None, **kwargs):
        super().__init__(master, **kwargs, scrollbar_fg_color="transparent")
        self.grid_columnconfigure(0, weight=1)

        self.command = command
        self.radiobutton_variable = customtkinter.StringVar()
        self.messages_list = []

    def add_message(self, item, to_left: bool):
        """
        Adds message to itself.

        :param item: Text of the message. Will be displayed in message label.
        :param to_left: This boolean represents to which side message will be stuck. Used to separate user's messages from recipient's messages.
        :return: Returns None.
        """
        label = CTkLabel(
            self, text=item, padx=5, width=100, height=40, bg_color="transparent", corner_radius=15, fg_color="gray"
        )
        if to_left:
            label.grid(row=len(self.messages_list), column=0, pady=(0, 10), sticky="w")
        else:
            label.grid(row=len(self.messages_list), column=0, pady=(0, 10), sticky="e")
        self.messages_list.append(label)

    def clear_conversation(self):
        """
        Clears all messages in opened chat.

        :return: Returns None.
        """
        for label in self.messages_list:
            label.destroy()

    def reload_all_messages(self, mess: list, recipient_username):
        """
        Clears all messages in opened chat and then reloads message in given dialog.

        :param mess: List of all user's messages. Only messages in given dialog will be shown.
        :param recipient_username: Dialog name.
        :return: Returns None.
        """
        self.clear_conversation()
        mess = [mes for mes in mess if mes[0] == recipient_username or mes[1] == recipient_username]
        for mes in mess:
            if mes[0] == USERNAME:
                self.add_message(mes[2], to_left=False)
            else:
                self.add_message(mes[2], to_left=True)

    def remove_message(self, item):
        """
        Removes single message from itself.

        :param item: Text of message, that should be removed.
        :return: Returns None.
        """
        for message in self.messages_list:
            if item == message.cget("text"):
                message.destroy()
                self.messages_list.remove(message)
                return

    def open_chat(self, recipient_username: str, header: CTkLabel):
        """
        Loads messages for dialog, saves dialog in CURRENT_CHAT.

        :param recipient_username: dialog name.
        :param header: app header, that shows current dialog name.
        :return: Returns None.
        """
        global CURRENT_CHAT
        if recipient_username != "New chat +":
            self.reload_all_messages(All_messages, recipient_username)
            CURRENT_CHAT = recipient_username
            header.configure(text=recipient_username)
        else:
            dialog = customtkinter.CTkInputDialog(text="Type recipient's username", title="New chat")
            text = dialog.get_input()
            self.reload_all_messages(All_messages, text)
            CURRENT_CHAT = text
            header.configure(text=text)


def get_recipients() -> list:
    """
    Checks All_messages list for different dialogs and returns list of usernames of dialogs.

    :return:
    """
    chats_t = []
    for mes in All_messages:
        if (mes[0] != USERNAME and mes[0] not in chats_t) or (mes[1] != USERNAME and mes[1] not in chats_t):
            if mes[0] == USERNAME:
                chats_t.append(mes[1])
            else:
                chats_t.append(mes[0])
    return chats_t


def sync_log(user_login, password, user_step):
    """
    Synchronous function that loads user's state and credentials. that could be caught later with update() function.

    :param str user_login: User's login, that he entered.
    :param str password: User's password, that he entered.
    :param str user_step: New state of user.
    :return: Returns None.
    """
    global USER_STEP, PASSWORD, USERNAME
    USER_STEP = user_step
    PASSWORD = password
    USERNAME = user_login


async def update():
    """
    Loop that proceeds dialog with server. Receives updates and displays it in application. Also sends messages if messages queue is not empty.

    Run it in new thread to avoid app loop, blocking asynchronous code.

    :return: Returns None.
    """
    global All_messages
    while True:
        print("sada")
        if USER_STEP == "logged":
            result = await get_history(TOKEN)
            if result and result is not None:
                if All_messages != result:
                    All_messages = result
                    chats_frame.reload_all_chats(get_recipients(), recipient_label)
            if to_send:
                await new_message(to_send[0][0], to_send[0][1], TOKEN)
                del to_send[0]
        elif USER_STEP == "waiting":
            await login(app.frame, app.login_background, USERNAME, PASSWORD, app)
        elif USER_STEP == "register":
            await create_account_and_login(app.frame, app.login_background, USERNAME, PASSWORD)
        await asyncio.sleep(1)


def send_message(message_text, text_input: customtkinter.CTkEntry):
    """
    Appears message to messages to send queue. They can be caught by update function after.

    :param str message_text: Text of message.
    :param text_input: input that used as textbox for messages. Used here to clear it after send.
    :return: returns None.
    """
    to_send.append([CURRENT_CHAT, message_text])
    text_input.delete(0, len(message_text))


def popup(message: str, master):
    """
    Makes simple popup with message. User for displaying errors.

    :param str message: text, that will be placed in popup.
    :param customtkinter.CTk master: master application, main window.
    :return: returns None.
    """
    if master.toplevel_window is not None and master.toplevel_window.winfo_exists():
        master.toplevel_window.focus()
    master.toplevel_window = ToplevelWindow(master, message)


def load_main_window(bg, master):
    """
    Loads messenger main screen, where all chats and messages appear.

    :param bg: label with background image. Its used as master for all frames.
    :param master: master application. Used here for grid split.
    :return: returns None when loaded.
    """
    global recipient_label, chats_frame

    new_bg = customtkinter.CTkImage(Image.open("./assets/new_bg.jpg"), size=(1000, 700))
    bg.configure(image=new_bg)
    bg.grid_configure(columnspan=3, rowspan=3)
    bg.grid_columnconfigure(0, weight=1)
    bg.grid_rowconfigure(0, weight=1)

    chats_label = CTkLabel(master=master, text="Chats", font=("Century Gothic", 38), width=270, corner_radius=100)
    recipient_label = CTkLabel(master=master, text="Select chat", font=("Century Gothic", 38), width=720)
    messages_frame = ScrollableMessagesFrame(master, width=700, height=580)
    chats_frame = ScrollableChatsFrame(master, messages_frame, width=250, height=630)

    recipient_label.grid(row=0, column=1, padx=10, pady=0, columnspan=2)
    messages_frame.grid(row=1, column=1, padx=10, pady=0, columnspan=2)
    chats_label.grid(row=0, column=0, padx=10, pady=0, sticky="w")
    chats_frame.grid(row=1, column=0, padx=10, pady=0, rowspan=2)

    send_input = customtkinter.CTkEntry(
        master=master, width=620, placeholder_text="Write message", font=("Century Gothic", 18)
    )
    send_input.grid(row=2, column=1, padx=10, pady=0, sticky="w")

    send_btn = CTkButton(
        master=master, width=30, height=30, text="➤", command=lambda: send_message(send_input.get(), send_input)
    )
    send_btn.grid(row=2, column=2, sticky="w", padx=10, pady=10)

    messages_frame.reload_all_messages(All_messages, "")
    recipients = get_recipients()
    chats_frame.reload_all_chats(recipients, recipient_label)


async def create_account_and_login(login_frame, bg, username, password, master):
    """
    Called when user entered credentials and clicked "or create new account" in login menu.

    :param login_frame: frame, which should be removed if user logged in.
    :param bg: label with background image. Its used as master for all frames.
    :param username: username, given by user.
    :param password: password, given by user.
    :param master: master application. Used here for grid split.
    :return: Runs load_main_window on success, otherwise loads popup with error. Returns None.
    """
    global USERNAME, TOKEN
    USERNAME = username
    login_frame.destroy()
    await get_worker_address_async()
    result = await register(username, password)
    if result is None:
        popup("Registration failed, check credentials", master)
    result = await get_token(username, password)
    if not result:
        popup("There is error on server side, please send report with code 207", master)
    load_main_window(bg, master)


async def login(login_frame, bg, username, password, master):
    """
    Called when user entered credentials and clicked "login" in login menu.

    :param login_frame: frame, which should be removed if user logged in.
    :param bg: label with background image. Its used as master for all frames.
    :param username: username, given by user.
    :param password: password, given by user.
    :param master: master application. Used here for grid split.
    :return: Runs load_main_window on success, otherwise loads popup with error. Returns None.
    """
    global All_messages, USERNAME, TOKEN, USER_STEP
    USERNAME = username
    login_frame.destroy()
    await get_worker_address_async()
    TOKEN = await get_token(username, password)
    if not TOKEN:
        popup("Login failed, check credentials", master)
    load_main_window(bg, master)
    USER_STEP = "logged"


class MyApp(customtkinter.CTk):
    """
    Custom Application class. Automatically loads login frame.
    """

    def __init__(self):
        super().__init__()
        customtkinter.set_appearance_mode("light")
        customtkinter.set_default_color_theme("dark-blue")

        self.geometry("1000x700")
        self.title("Login")
        self.resizable(False, False)

        self.img1 = customtkinter.CTkImage(Image.open("./assets/bg.jpg"), size=(1000, 700))
        self.login_background = customtkinter.CTkLabel(
            master=self,
            image=self.img1,
            anchor="w",
            text="Loading...",
            text_color="#042f69",
            font=("Century Gothic", 38),
        )
        self.login_background.grid_columnconfigure(0, weight=1)
        self.login_background.pack()

        self.frame = customtkinter.CTkFrame(
            master=self.login_background, width=600, height=440, corner_radius=30, fg_color="transparent"
        )
        self.frame.place(relx=0.5, rely=0.5, anchor=tkinter.CENTER)

        self.l2 = customtkinter.CTkLabel(master=self.frame, text="Log into your Account", font=("Century Gothic", 26))
        self.l2.pack(padx=10, pady=35)

        self.username_textbox = customtkinter.CTkEntry(
            master=self.frame, width=300, height=40, placeholder_text="Username", font=("Century Gothic", 18)
        )
        self.username_textbox.pack(padx=10, pady=5)

        self.password_textbox = customtkinter.CTkEntry(
            master=self.frame, width=300, height=40, placeholder_text="Password", show="*", font=("Century Gothic", 18)
        )
        self.password_textbox.pack(padx=10, pady=40)

        self.button1 = customtkinter.CTkButton(
            master=self.frame,
            width=300,
            height=40,
            text="Login",
            command=lambda: sync_log(app.username_textbox.get(), app.password_textbox.get(), "waiting"),
            corner_radius=6,
            font=("Century Gothic", 20),
        )
        self.button1.pack(padx=10, pady=5)

        self.button2 = customtkinter.CTkButton(
            master=self.frame,
            height=20,
            width=90,
            text="Or create account",
            command=lambda: sync_log(app.username_textbox.get(), app.password_textbox.get(), "register"),
            corner_radius=6,
            fg_color="transparent",
            text_color="#9f6ec9",
            hover_color="#85b7fb",
            font=("Century Gothic", 15),
        )
        self.button2.pack(padx=10, pady=5)

    def run(self):
        """
        Start of application loop.

        :return: Returns None.
        """
        self.mainloop()


if __name__ == "__main__":
    """
    Entry point of application.
    """
    app = MyApp()
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    threading.Thread(target=lambda: loop.run_until_complete(update())).start()
    app.run()
